(*gen_string*)
let rec gen_string = function (n, what) ->
if n==0 then []
        else
        what :: gen_string (n-1, what) ;;

(*gen_square*)
let gen_square = function (n) ->
  (gen_string(n, "u")@gen_string(n, "r")@
  gen_string(n, "d")@gen_string(n, "l"));;

(*gen_rect*)
let gen_rect = function (n, m) ->
  (gen_string(n, "u")@gen_string(m, "r")@
  gen_string(n, "d")@gen_string(m, "l"));;

(*countups*)
let rec countups = function(alist, n) ->
  if (alist = []) then n
    else
    if (List.hd alist) = "u"
      then countups(List.tl alist, n + 1)
      else countups(List.tl alist, n);;

(*consec_counts*)
let rec consec_counts = function(alist, count, what) ->
  if alist = [] then ([], count)
    else if (List.hd alist) = what
      then consec_counts(List.tl alist, count + 1, what)
      else (alist, count);;

(*Auxiliary Functions for sq*)
let remainder = function(list, count) -> list;;

let length = function(list, count) -> count;;

let sq_l = function(alist) ->
  if(length (consec_counts(alist, 0, "l")) > 0)
    then true
    else false;;

let sq_d = function(alist) ->
  if(length (consec_counts(alist, 0, "d")) > 0)
    then sq_l(remainder(consec_counts(alist, 0, "d")))
    else false;;

let sq_r = function(alist) ->
  if(length (consec_counts(alist, 0, "r")) > 0)
    then sq_d(remainder(consec_counts(alist, 0, "r")))
    else false;;


let sq_u = function(alist) ->
  if(length (consec_counts(alist, 0, "u")) > 0)
    then sq_r(remainder(consec_counts(alist, 0, "u")))
    else false;;

(*sq*)
let sq = function(alist) ->
  sq_u(alist);;


(*sq_all - use same aux functions but add _all and check for empty list on last one*)



(*skipping a few functions here*)


(*one_shift*)
let one_shift = function (alist) ->
  List.tl alist@[List.hd alist];;


(*Match N******)


(*Auxilary functions*)
