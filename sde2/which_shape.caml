(*gen_string*)
let rec gen_string = function (n, what) ->
if n==0 then []
        else
        what :: gen_string (n-1, what) ;;

(*gen_square*)
let gen_square = function (n) ->
  (gen_string(n, "u")@gen_string(n, "r")@
  gen_string(n, "d")@gen_string(n, "l"));;

(*gen_rect*)
let gen_rect = function (n, m) ->
  (gen_string(n, "u")@gen_string(m, "r")@
  gen_string(n, "d")@gen_string(m, "l"));;

(*countups*)
let rec countups = function(alist, n) ->
  if (alist = []) then n
    else
    if (List.hd alist) = "u"
      then countups(List.tl alist, n + 1)
      else countups(List.tl alist, n);;

(*consec_counts*)
let rec consec_counts = function(alist, count, what) ->
  if alist = [] then ([], count)
    else if (List.hd alist) = what
      then consec_counts(List.tl alist, count + 1, what)
      else (alist, count);;

(*sq*)
let sq = function(alist) ->
  

(*skipping a few functions here*)


(*one_shift*)
let one_shift = function (alist) ->
  List.tl alist@[List.hd alist];;

(*)

(*Match N******)
